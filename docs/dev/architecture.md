# FastQTools 现代化架构设计文档

## 📋 文档信息

- **项目名称**: FastQTools
- **文档版本**: 4.0.0
- **更新日期**: 2025年7月31日
- **设计目标**: 现代化C++20 + 高性能并行处理 + 稳定的构建系统
- **目标读者**: 开发团队、架构师

## 🎯 核心设计原则

`fastqtools` 的架构遵循以下核心原则：

1.  **性能优先 (Performance-First)**：在所有设计决策中，优先考虑如何最大化处理吞吐量和资源利用率。
2.  **现代化 C++ (Modern C++)**：全面拥抱 C++20 标准，利用其现代特性编写更安全、更简洁、更高效的代码。
3.  **务实与迭代 (Pragmatism & Iteration)**：采用经过工业界验证的、高性价比的技术方案，避免“过早优化”和不必要的复杂性。架构通过迭代演进，而非“大爆炸式”重构。
4.  **高内聚，低耦合 (High Cohesion, Low Coupling)**：通过定义清晰的抽象接口和模块边界，将系统的不同部分解耦，以提高代码的可维护性、可测试性和可扩展性。

## 🔧 核心技术栈

| 领域 | 技术/库 | 决策理由 |
| :--- | :--- | :--- |
| **语言** | C++20 | 提供现代化的语言特性，性能卓越。 |
| **构建系统** | CMake | C++ 项目的事实标准，采用现代化的基于目标的配置方式。 |
| **依赖管理** | Conan | 自动化管理第三方库，保证构建环境的一致性。 |
| **并发模型** | Intel oneTBB | 提供高性能、经过验证的并行计算构建块（特别是 `parallel_pipeline`）。 |
| **命令行解析** | cxxopts | 轻量、现代、易于使用的命令行参数解析库。 |
| **日志** | spdlog | 高性能、功能丰富的日志库。 |
| **测试** | GoogleTest | 功能强大且灵活的单元测试框架。 |

## 🚀 并发模型：务实的 `tbb::parallel_pipeline`

`fastqtools` 的核心性能瓶颈在于传统的单线程处理模式，即I/O操作与CPU计算无法重叠。为解决此问题，我们选择了 **`tbb::parallel_pipeline`** 作为核心并发模型。

这是一个经过审慎权衡后的决策，主要基于以下考量：

1.  **高投入产出比**：`tbb::parallel_pipeline` 能以极低的开发复杂度和代码量，直接解决“I/O与CPU重叠”这一核心矛盾，可以快速、安全地获得显著的性能提升。
2.  **避免过早优化**：更复杂的模型（如 `tbb::flow_graph`）试图解决“不同计算任务间的资源争抢”问题。然而，这在当前阶段是一个**未被验证的假设**。我们遵循数据驱动的原则，先用最简单的有效模型解决主要矛盾，再通过性能分析来决定是否需要进一步优化。
3.  **内置健壮性**：该组件内置了**背压机制**，能自动平衡各阶段速度，防止内存溢出。同时，TBB 作为一个工业级标准库，其稳定性和性能经过了长期和广泛的验证。

## 🏗️ 构建系统演进：从 C++20 模块到传统头文件

在本次重构中，我们对构建系统进行了深入的探索和实践。

### 最初目标：全面的C++20模块化

我们最初的目标是全面采用C++20模块，以期获得最清晰的依赖关系和最快的编译速度。

### 遇到的挑战：工具链的局限性

在实践过程中，我们发现当前项目所使用的GCC 15.1.0编译器及相关工具链，对C++20模块的支持存在一些无法绕过的限制，导致了严重的编译问题。

### 最终决策：回归稳定高效的传统结构

面对这些来自工具链底层的限制，我们做出了一个务实的决定：**在当前阶段放弃C++20模块，回归到稳定、可靠的传统头文件/源文件（`.h/.cpp`）结构。**

这一决策的优势在于：
-   **保证了项目的可构建性**：这是最优先的目标。
-   **保持 C++20 的语言特性**：我们使用 C++20 标准的现代特性开展开发工作。
-   **维持了模块化思想**：通过现代CMake，我们将代码库组织成高内聚、低耦合的静态库目标，在逻辑上实现了模块化。

未来的某一天，当编译器和构建系统对C++模块的支持足够成熟和稳定时，我们可以再次平滑地迁移到模块化。